# 《Linux程序设计》学习笔记

Linux 标准只是让他们相似，并不是二进制兼容，不像 Windows。

> 在 本书 的 最后 一章， 我们 简要 介绍 了 Linux 的 标准， 正是 这些 标准 使得 不同 厂商 的 Linux 发行 版 保持 了 足够 的 相似性， 从而 使我们 编写 的 程序 可以 在 不同 的 Linux 发行 版 上 运行。
>



注意一下 unix 里面的 dbm 接口。

>  dbm 库 就是 一个 例子， 它是 一组 可 重用 的 函数， 而 不是 单一 的 数据库 管理 程序。
>



只要 这个 设备 有 处理器， 就会 有人 试图 让 Linux 运行 其上，这就是开放源代码的好处。

> 包括 基于 32 位 和 64 位 Intel _x_ 86 及其 兼容 处理器 的 个人 计算机、 使用 SUN SPARC、 IBM PowerPC、 AMD Opteron、 Intel Itanium 的 工作站 和 服务器， 甚至 一些 手持 PDA 和 Sony PS2/ PS3 游戏 机。 只要 这个 设备 有 处理器， 就会 有人 试图 让 Linux 运行 其上。
>



copyleft 的 目的 是 防止 有人 给 自由 软件 的 使用 加上 限制

> 这份 许可证 阐述 了 copyleft（ copyleft 是 一个 生 造 的 词， 是 英文 copyright 的 反话） 的 概念。 copyleft 的 目的 是 防止 有人 给 自由 软件 的 使用 加上 限制。
>



Unix 跟 C 语言的历史。

> 事实上， UNIX 的 第一个 版本 是在 1969 年 用 PDP 7 机器 的 汇编语言 编写 的。 差不多 也在 那个 时候， Dennis Ritchie 发明 了 C 语言， 并于 1973 年 与 Ken Thompson 一 起用 C 语言 重写 了 整个 UNIX 内核， 这 在那 个 连系 统 软件 都是 用 汇编语言 编写 的 时代 的 确是 个 了不起 的 壮举。
>



Windows 的 分号 与 UNIX 的 冒号。

> 注意， Linux 像 UNIX 一样， 使用 冒号（:） 分隔 PATH 变量 里 的 条目， 而 不是 像 MS- DOS 和 Windows 使用 分号（;）。（ UNIX 使用 冒号: 在先， 所以 应该 问 微软 为什么 Windows 要 采用 不同 的 方式， 而 不是 问 UNIX 为什么 与之 不同！） 下面 是 一个 PATH 变量 的 例子：
>



> 许多 年来， 不同 厂商 销售 的 类 UNIX 系统 中 所带 的 C 语言 编译器 均 包含 不同 的 功能 和 选项， 但它 们 一般 都 称为 cc。
>



`grep EXIT_ *.h`  grep 居然可以搜索文件里面的内容。

> 用 grep 命令 来 搜索 包含 某些 特定 定义 和 函数 原型 的 头 文件 是 很 方便 的。 假设 想知道 用于 从 程序 中 返回 退出 状态 的# define 定义 的 名字， 你 只需 切换 到/ usr/ include 目录 下， 然后 用 grep 命令 搜索 可能 的 名字 部分， 如下 所示：
>



`-lm` 标志 的 另一个 好处 是 如果 有 共享 库， 编译器 会 自动 选择 共享 库

> -lm（ 在 字母 l 和 m 之间 没有 空格） 是 简写 方式（ 简写 在 UNIX 环境 里 很有 用）， 它 代表 的 是 标准 库 目录（ 本例 中 是/ usr/ lib） 中 名为 libm. a 的 函数 库。- lm 标志 的 另一个 好处 是 如果 有 共享 库， 编译器 会 自动 选择 共享 库。



`-L` 指定库的搜索路径

> 但 你也 可以 通过 使用- L（ 大写字母） 标志 为 编译器 增加 库 的 搜索 路径。
>



![linux-program-design-1-1](D:\0-博客\学习笔记\《Linux程序设计》\linux-program-design-1-1.png)



一定要学会用 man 手册。

> 绝大多数 Linux 系统 都为 系统 编程 接口 和 标准 工具 提供 了 很好 的 文档。 这是 因为， 从 早期 的 UNIX 系统 开始， 程序员 就被 鼓励 为 他们的 应用 程序 提供 手册 页。 这些 手册 页 都可以 通过 电子 形式 获得， 有时 也会 以 印刷品 的 形式 提供。
>



`grep -l POSIX $ file`，grep 可以搜索文件的。



Linux 里面的 dialog 工具。

![linux-program-design-1-2](D:\0-博客\学习笔记\《Linux程序设计》\linux-program-design-1-2.png)



注意系统调用 ioctl 。

> 系统 调用 ioctl 用于 提供 一些 与 特定 硬件 设备 有关 的 必要 控制（ 与 正常 的 输入 输出 相反）， 所以 它的 用法 随 设备 的 不同 而 不同。 例如， ioctl 调用 可以 用于 回 绕 磁带 机 或 设置 串行 口 的 流 控 特性。 因此， ioctl 并不 需要 具备 可移植性。 此外， 每个 驱动 程序 都 定义 了 它自己 的 一组 ioctl 命令。
>



3 个已经打开的文件描述符。

>  当 一个 程序 开始 运行时， 它 一般 会有 3 个 已经 打开 的 文件 描述 符： 0： 标准 输入 l： 标准 输出 2： 标准 错误
>



open 与 `fopen` 是两个不同的函数，open 是 系统调用，而 `fopen` 是标准 IO 库里面的函数。



这些格式要很好的注意一下。

![linux-program-design-1-3](D:\0-博客\学习笔记\《Linux程序设计》\linux-program-design-1-3.png)





把错误码转成字符串的机制， strerror。

> strerror 函数 把 错误 代码 映射 为 一个 字符串， 该 字符串 对 发生 的 错误 类型 进行 说明。 这 在 记录 错误 条件 时 十分 有用。



environ 变量是环境变量数组，可以遍历的。

> extern char **environ;
>



`tmpfile` 函数创建临时文件，非常方便。

> 如果 遇到 需要 立刻 使用 临时 文件 的 情况， 你 可 以用 tmpfile 函数 在给 它 命名 的 同时 打开 它。 这点 非常 重要， 因为 另一个 程序 可能 会 创建 出 一个 与 tmpnam 返回 的 文件名 同名 的 文件。 tmpfile 函数 则 完全避免 了 这个 问题 的 发生：
>



curses 库可以把文字显示在屏幕上，可以说是文字 gui 库。效果如下：

![linux-program-design-1-4](D:\0-博客\学习笔记\《Linux程序设计》\linux-program-design-1-4.png)

> dbm 数据库： 一个 大多数 Linux 系统 都 提供 的、 基本 的、 不 基于 SQL 的 数据库 函数 库。
>



注意 LSB 标准

> 现在 我们将 讨论 比 C 语言 代码 高一 个 层次 的 由 操作系统 提供 的 接口（ 系统 函数）。 这一 级别 的 标准化 工作 由 下面 两个 组件 构成： 由 函数 库 提供 的 函数 和 由 底层 的 操作系统 提供 的 系统 调用。 在这 两个 组件 之中 又 分别 包含 两个 层次 的 细节： 提供 的 是 哪一个 接口 和 接口 的 定义。



线程有自己的栈，所以有自己的局部变量。

> 当 在 进程 中 创建 一个 新 线程 时， 新的 执行 线程 将 拥有 自己的 栈（ 因此 也有 自己的 局部 变量）， 但 与 它的 创建 者 共享 全局 变量、 文件 描述 符、 信号 处理 函数 和 当前 目录 状态。
>



1996年 `LinuxThread`。

> Linux 系统 在 1996 年 第一次 获得 线程 的 支持， 我们 常把 当时 使用 的 函数 库 称为 LinuxThread。
>



可重入函数版本。

> 例如， 函数 名 gethostbyname 将 变为 gethostbyname_ r。
>
