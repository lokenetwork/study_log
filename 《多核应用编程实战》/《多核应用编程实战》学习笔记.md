# 《多核应用编程实战》学习笔记

![1-1](1-1.png)

面积换核心。

![1-2](1-2.png)

硬件线程与软件线程。

![1-3](1-3.png)

![1-4](1-4.png)

分支会影响预测，看看有什么优化方法。

![1-5](1-5.png)

CPU 内部是用广播的方式来实现缓存一致性。

![1-6](1-6.png)

两种内存架构。
1，UMA（统一内存架构）
2，ccNUMA（缓存一致的非统一内存架构）

![1-7](1-7.png)

函数调用约定，是ABI 用的一部分。

![1-8](1-8.png)

![1-9](1-9.png)

历史的 64 位技术。64位会用寄存器传参。

![2-1](2-1.png)

锁原理，实际上就是一个变量好像。因为赋值只需要一条指令，所以一条指令就是原子性的。

锁的原理就是用单条指令封装多条指令成 原子操作。操作是单条，还是多条，是从不同的角度来看的。

![2-2](2-2.png)

进程的数据布局。

![2-3](2-3.png)

![2-3-1](2-3-1.png)

多进程架构的缺点，增加 TLB跟缓存的未命中率。

![2-4](2-4.png)

注意内存排序指令。

![2-5](2-5.png)



并行编程的关注点，缓存，以及是否能扩展多个处理器。

![2-6](2-6.png)

编译器处理静态库的时候无法利用内联优化



Windows 不是用的位置无关的动态库方式，

![2-7](2-7.png)

![2-8](2-8.png)

延迟加载什么时候会失效。

![2-9](2-9.png)

如何提升数据读取性能。

![3-1](3-1.png)

a 跟 b 指向不同的内存。

优化技巧，让编译器能看到更多的代码。

![3-2](3-2.png)

移位 比 乘除更快。

![3-3](3-3.png)

![3-4](3-4.png)



编译优化还有一个 fast 宏。

![3-5](3-5.png)

跨文件优化，可能需要把两个文件 一起编译，也就是需要 gcc 同时编译两个文件，不能独立编译。

![3-6](3-6.png)

内联太多会导致程序代码太大，指令缓存命中率下降。
因此通常只内联有利于性能提示的函数，避免内联只会增加指令缓存需求量的函数。

![3-7](3-7.png)

第一次知道，原来可以配置反馈文件来收集程序的运行时信息。
然后把运行时信息再输出给编译器来优化性能。

![3-8](3-8.jpg)

![3-9](3-9.png)

解决别名的方法。

![4-1](4-1.png)

尽量不要手写汇编，应该适当使用编译器的标记。

![4-2](4-2.png)

容器技术，Solaris 的 Zone，FreeBSD 的 Jail。

![4-3](4-3.png)

两种虚拟化的技术方案。

![4-5](4-4.png)

![4-5](4-5.png)

流水线式的并行方法。

![4-6](4-6.png)

检查热点代码，可以用运行时配置文件。

![4-7](4-7.png)

Helgrind 可以检测数据争用。

![4-8](4-8.png)

注意 屏障函数。

![4-9](4-9.png)

无锁是通过更低级别的原子操作 CAS 实现的。C++ 的 automatic 应该就是通过 CAS 实现的。反汇编看一下。

 ![5-1](5-1.png)



__thread 关键字。

![5-2](5-2.png)

控制大多数线程到某个位置再一起往下跑。

![5-3](5-3.png)

注意 OpenMP。

![5-4](5-4.png)

编译器可以实现一定程度的并行化。

![5-5](5-5.png)

OpenMP 也可以用互斥锁。

![5-6](5-6.png)



弱内存排序。

![5-7](5-7.png)

操作系统提供了原子操作。

![5-8](5-8.png)

ABA 问题可以用版本号来解决。

![5-9](5-9.png)

快排的多线程实现。

![6-1](6-1.png)

内存优化。

![6-2](6-2.png)

![6-3](6-3.png)
